/*
进程：运行的程序
线程：进程中的进程，线程的数量取决于cpu核数

创建线程：
#include<thread>
std::thread t(function_name,args...);
function_name：线程入口点的函数或可调用对象
args...：传递给函数的参数
thread t(printHelloWorld,"heloo,fuck");
t.join();//检查线程是否结束，结束后主线程在继续运行
t.detach();//分离线程，即使主线程结束，线程也继续在后台执行
bool in = t.joinable();//joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false

常见错误
1. 传递临时变量的问题：线程要引用类型，却传递临时变量
std::ref()：传递引用类型
2. 传递指针或引用指向局部变量的问题：运行到线程时，局部变量已经被释放掉了，此时线程调用空指针
全局变量解决
3. 传递指针或引用指向已释放的内存的问题：跟2差不多，就是变成手动释放
手动释放时机要在线程结束后，或者用智能指针
4. 类成员函数作为入口函数，类对象被提前释放：跟3差不多，就是传参变成类对象，主线程运行到return就释放了
thread t(&A::foo,&a);
&A::foo：是函数指针，表示要在线程中运行的类 A 的成员函数 foo。
&a：是指向对象 a 的指针，告诉 thread 使用 a 对象调用 foo。
5.入口函数为类的私有成员函数
创建一个友元函数，将私有成员函数放进去
*/
