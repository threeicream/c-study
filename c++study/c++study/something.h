/*
C++ 和 C 是两种广泛使用的编程语言，它们在多个方面有显著区别：

### 1. **面向对象编程 (OOP)**
- **C++**: 支持面向对象编程。它引入了类和对象的概念，可以封装数据和函数，还支持继承和多态。
- **C**: 是面向过程的编程语言，不支持类和对象的概念。

### 2. **函数和方法**
- **C++**: 函数可以是类的一部分（称为方法）。C++ 支持函数重载和运算符重载。
- **C**: 所有的函数都是全局的，不支持函数重载和运算符重载。

### 3. **标准库**
- **C++**: 拥有丰富的标准模板库 (STL)，包括容器类、算法和迭代器。
- **C**: 标准库相对简单，主要包括输入/输出操作、字符串操作和内存分配等基本功能。

### 4. **内存管理**
- **C++**: 除了传统的 C 风格的内存管理（`malloc` 和 `free`），还支持新的和删除操作符（`new` 和 `delete`），并引入了 RAII（资源获取即初始化）等高级特性来简化内存管理。
- **C**: 主要依赖手动管理内存，使用 `malloc` 和 `free` 函数。

### 5. **模板**
- **C++**: 支持模板编程，允许编写泛型代码，可以创建通用的数据结构和算法。
- **C**: 不支持模板编程。

### 6. **异常处理**
- **C++**: 支持异常处理机制，使用 `try`、`catch` 和 `throw` 关键字。
- **C**: 不支持异常处理机制，错误处理通常通过返回值和全局变量（如 `errno`）来实现。

### 7. **命名空间**
- **C++**: 引入了命名空间（`namespace`）以避免命名冲突。
- **C**: 没有命名空间的概念，命名冲突是一个常见的问题。

### 8. **编译器支持**
- **C++**: 现代编译器（如 g++, clang++）支持 C++ 的所有特性，并持续更新。
- **C**: 传统编译器（如 gcc，clang）支持 C 的所有特性，并相对稳定。

### 9. **使用领域**
- **C++**: 广泛应用于系统软件、游戏开发、实时系统、大型项目等需要高性能和复杂性的领域。
- **C**: 主要用于系统编程（如操作系统、嵌入式系统）、底层编程和性能要求极高的领域。

### 10. **兼容性**
- **C++**: 基本上是 C 的超集，几乎所有 C 程序都可以在 C++ 编译器下编译运行，但反之不成立。
- **C**: 不支持 C++ 特性，因此 C++ 代码不能直接在 C 编译器下编译。

通过这些差异可以看出，C++ 提供了更多的高级特性和编程工具，使得编写复杂应用程序更加方便，而 C 则以其简单和高效被广泛应用于底层系统和性能关键的场景。





面向对象编程 (OOP) 和面向过程编程 (POP) 是两种不同的编程范式，各有其特点和适用场景。下面对它们进行详细解释：

### 面向过程编程 (Procedural Programming)
面向过程编程是一种以过程（即函数或子程序）为中心的编程范式，主要关注的是解决问题的步骤和逻辑。

#### 主要特点：
1. **模块化**：将程序分解成若干个函数，每个函数完成特定的任务。
2. **函数调用**：通过调用函数来执行特定的任务，函数可以互相调用。
3. **顺序执行**：程序按照代码的顺序逐步执行。
4. **全局数据**：数据可以在函数之间共享，通常通过全局变量。
5. **重用性**：通过函数的复用，提高代码的重用性。

#### 优点：
- 简单直接，容易理解和实现。
- 对于小型、简单的程序非常有效。
- 执行效率高，内存占用少。

#### 缺点：
- 随着程序规模的增大，代码维护变得复杂。
- 数据和函数之间的关系较为松散，难以进行数据保护和隐藏。
- 缺乏抽象和封装，难以应对复杂的应用场景。

### 面向对象编程 (Object-Oriented Programming)
面向对象编程是一种以对象为中心的编程范式，主要关注的是数据及其操作方法的封装和抽象。

#### 主要特点：
1. **对象**：将数据和操作这些数据的方法封装在一起，称为对象。
2. **类**：对象的模板或蓝图，通过类可以创建多个具有相同属性和行为的对象。
3. **封装**：通过将数据和方法封装在对象内部，实现信息隐藏。
4. **继承**：子类继承父类的属性和方法，代码重用性高。
5. **多态**：通过接口或继承，实现不同对象对同一方法的不同实现。
6. **抽象**：通过抽象类和接口，定义对象的通用行为。

#### 优点：
- 提高代码的可维护性和可扩展性。
- 通过封装实现信息隐藏，提高代码的安全性。
- 通过继承和多态实现代码的重用和灵活性。
- 更容易实现复杂的应用场景和大型项目。

#### 缺点：
- 初学者学习曲线较陡峭，理解和实现复杂。
- 程序执行效率可能低于面向过程编程。
- 需要更多的内存和处理能力。

### 总结
- **面向过程编程**：适用于小型、简单的程序，强调过程和函数，关注解决问题的步骤。
- **面向对象编程**：适用于大型、复杂的程序，强调对象和类，关注数据和操作方法的封装和抽象。

这两种编程范式各有其适用场景，开发者可以根据具体需求选择合适的编程方法。

int main()
{
	using namespace std;
	vector<string>v1 ;
	string s;
	while (getline(cin, s))
		v1.push_back(s);
	for (auto it = v1.begin(); it != v1.end() && !it->empty(); it++)
	{
		for (auto it2 = it->begin(); it2 != it->end(); it2++)
			*it2 = toupper(*it2);
	}
	for (auto a : v1)
		cout << a << endl;

	return 0;
}
//其中，v1.begin() 返回的是一个指向 vector<string> 中第一个 string 元素的迭代器，而 it->begin() 返回的是一个指向 string 中第一个字符的迭代器。
在你的代码中，it 是一个 vector<string>::iterator，因此 it->begin() 是一个 string::iterator。
这两个迭代器的类型和语义完全不同，所以不能将 v1.begin() 直接替换为 it->begin()。

{
int it[3][4];
	size_t cnt = 0;
	for(auto &row:it)
		for (auto& col : row)
		{
			col = cnt;
			cnt++;
		}
	/*for (int(&a)[4] : it)
		for (int b : a)
			cout << b << ' ';*/

	/*for (size_t i = 0; i < 3; i++)
		for (size_t j = 0; j < 4; j++)
			cout << it[i][j] << ' ';*/

	//for (int_arry* p = begin(it); p != end(it); p++)
		//for (int* q = begin(*p); q != end(*p); q++)
			//cout << *q << ' ';

	/*for (auto p = it; p != it + 3; p++)
		for (auto q = *p; q != *p+4; q++)
			cout << *q << ' ';*/
//}
/*
 __func__
 __FILE__
 __TIME__
 __DATE__
 NDEBUG 是一个预处理宏，用于控制 C++ 中的断言（assertions）。
 当定义了 NDEBUG 时，所有的 assert 宏调用都会被忽略，即断言会被禁用。
 这通常在发布（release）版本中使用，以提高程序的运行效率，因为在发布版本中不需要进行断言检查。
*/
